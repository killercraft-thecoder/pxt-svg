{"entries":[{"timestamp":1756169824103,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":541,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":74,"length1":102,"diffs":[[1,"        \"device\": \"*\"\n"]]},{"start1":181,"length1":45,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":210,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"svgparse.ts","value":"class SVGParser {\n    private svgText: string;\n    private img: Image;\n    private viewBoxW: number;\n    private viewBoxH: number;\n\n    constructor(svgText: string) {\n        this.svgText = svgText;\n        this.img = image.create(160, 120);\n        this.viewBoxW = 160;\n        this.viewBoxH = 120;\n        this.parseViewBox();\n    }\n\n    private parseViewBox() {\n        let vbPos = this.svgText.indexOf(\"viewBox=\");\n        if (vbPos >= 0) {\n            let quote1 = this.svgText.indexOf('\"', vbPos);\n            let quote2 = this.svgText.indexOf('\"', quote1 + 1);\n            let parts = this.svgText.substr(quote1 + 1, quote2).split(\" \");\n            if (parts.length == 4) {\n                this.viewBoxW = parseFloat(parts[2]);\n                this.viewBoxH = parseFloat(parts[3]);\n            }\n        }\n    }\n\n    private scaleX(x: number): number {\n        return Math.round(x * 160 / this.viewBoxW);\n    }\n\n    private scaleY(y: number): number {\n        return Math.round(y * 120 / this.viewBoxH);\n    }\n\n    render(): Image {\n        let pos = 0;\n        while (true) {\n            let rectPos = this.svgText.indexOf(\"<rect\", pos);\n            let circPos = this.svgText.indexOf(\"<circle\", pos);\n            let linePos = this.svgText.indexOf(\"<line\", pos);\n\n            // Find the next tag in order\n            let nextPos = -1;\n            let tagType = \"\";\n            if (rectPos != -1 && (nextPos == -1 || rectPos < nextPos)) { nextPos = rectPos; tagType = \"rect\"; }\n            if (circPos != -1 && (nextPos == -1 || circPos < nextPos)) { nextPos = circPos; tagType = \"circle\"; }\n            if (linePos != -1 && (nextPos == -1 || linePos < nextPos)) { nextPos = linePos; tagType = \"line\"; }\n\n            if (nextPos == -1) break;\n\n            if (tagType == \"rect\") pos = this.parseRect(nextPos);\n            else if (tagType == \"circle\") pos = this.parseCircle(nextPos);\n            else if (tagType == \"line\") pos = this.parseLine(nextPos);\n        }\n        return this.img;\n    }\n\n    private parseRect(startPos: number): number {\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x = this.getAttr(tag, \"x\");\n        let y = this.getAttr(tag, \"y\");\n        let w = this.getAttr(tag, \"width\");\n        let h = this.getAttr(tag, \"height\");\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        this.img.fillRect(this.scaleX(x), this.scaleY(y), this.scaleX(w), this.scaleY(h), color);\n        return endPos;\n    }\n\n    private parseCircle(startPos: number): number {\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let cx = this.getAttr(tag, \"cx\");\n        let cy = this.getAttr(tag, \"cy\");\n        let r = this.getAttr(tag,\"r\")\n        let color = this.colorFromAttr(tag, \"fill\");\n        this.img.fillCircle(this.scaleX(cx), this.scaleY(cy), Math.round(r * (160 / this.viewBoxW)), color);\n        return endPos;\n    }\n\n    private parseLine(startPos: number): number {\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x1 = this.getAttr(tag, \"x1\");\n        let y1 = this.getAttr(tag, \"y1\");\n        let x2 = this.getAttr(tag, \"x2\");\n        let y2 = this.getAttr(tag, \"y2\");\n\n        let color = this.colorFromAttr(tag, \"stroke\");\n        this.img.drawLine(this.scaleX(x1), this.scaleY(y1), this.scaleX(x2), this.scaleY(y2), color);\n\n        return endPos;\n    }\n    // New: map an SVG hex color to your chosen palette\n    private colorFromAttr(tag: string, attrName: string): number {\n        let hex = this.getStringAttr(tag, attrName);\n        if (hex.length == 0) return 1; // default white if missing\n        if (hex.charAt(0) == '#') hex = hex.substr(1);\n\n        let r = parseInt(hex.substr(0, 2), 16);\n        let g = parseInt(hex.substr(2, 2), 16);\n        let b = parseInt(hex.substr(4, 2), 16);\n\n        // Your chosen palette: index -> [R,G,B]\n        const palette: number[][] = [\n            [255, 255, 255], // 1 white\n            [255, 0, 0],     // 2 red\n            [255, 192, 203], // 3 pink\n            [255, 255, 0],   // 5 yellow\n            [255, 165, 0],   // 4 orange\n            [0, 0, 0],       // 15 black\n            [139, 69, 19],   // 14 brown\n            [0, 0, 139],     // 8 dark blue\n            [0, 255, 255]    // 6 cyan-ish\n        ];\n        const paletteIndex: number[] = [1, 2, 3, 5, 4, 15, 14, 8, 6];\n\n        let bestIndex = 1;\n        let bestDist = 999999;\n        for (let i = 0; i < palette.length; i++) {\n            let dr = palette[i][0] - r;\n            let dg = palette[i][1] - g;\n            let db = palette[i][2] - b;\n            let dist = dr * dr + dg * dg + db * db;\n            if (dist < bestDist) {\n                bestDist = dist;\n                bestIndex = paletteIndex[i];\n            }\n        }\n        return bestIndex;\n    }\n\n    // Slightly refactored getAttr to get numbers\n    private getAttr(tag: string, name: string): number {\n        let valStr = this.getStringAttr(tag, name);\n        if (valStr.length > 0) return parseFloat(valStr);\n        return 0;\n    }\n\n    // New: get string attribute (for colors)\n    private getStringAttr(tag: string, name: string): string {\n        let pos = tag.indexOf(name + \"=\");\n        if (pos >= 0) {\n            let quote1 = tag.indexOf('\"', pos);\n            let quote2 = tag.indexOf('\"', quote1 + 1);\n            return tag.substr(quote1 + 1, quote2).trim();\n        }\n        return \"\";\n    }\n\n}"}]},{"timestamp":1756170600230,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"svgparse.ts","patch":[{"start1":4021,"length1":9,"diffs":[[1,"        const palette: number[][] = [\n            [255, 255, 255], // 1 white\n            [255, 0, 0],     // 2 red\n            [255, 192, 203], // 3 pink\n            [255, 255, 0],   // 5 yellow\n            [255, 165, 0],   // 4 orange\n            [0, 0, 0],       // 15 black\n            [139, 69, 19],   // 14 brown\n            [0, 0, 139],     // 8 dark blue\n            [0, 255, 255]    // 6 cyan-ish\n        ];\n        const paletteIndex: number[] = [1, 2, 3, 5, 4, 15, 14, 8, 6];\n"]]}]}]},{"timestamp":1756170600907,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":16,"length1":0,"diffs":[[1,"<svg version=\"1.1\" viewBox=\"0 0 32 32\" xmlns=\"http://www.w3.org/2000/svg\">\n <g>\n  <rect x=\"6\" y=\"5\" width=\"6\" height=\"4\" rx=\"1\" ry=\"1\" fill=\"#575757\"/>\n  <rect x=\"3\" y=\"7.0191\" width=\"26\" height=\"18\" rx=\"3\" ry=\"3\" fill=\"#c2bdbd\"/>\n  <rect x=\"3\" y=\"10\" width=\"26\" height=\"12\" fill=\"#575757\"/>\n </g>\n <circle cx=\"16\" cy=\"16\" r=\"4.5\" stroke=\"#c2bdbd\"/>\n <circle cx=\"15.5\" cy=\"14.5\" r=\"1\" fill=\"#c2bdbd\" stroke=\"#858585\"/>\n</svg>\n"]]},{"start1":443,"length1":1,"diffs":[[1,""]]}]},{"type":"edited","filename":"svgparse.ts","patch":[{"start1":1965,"length1":318,"diffs":[[1,""]]},{"start1":2007,"length1":2729,"diffs":[[1,""]]},{"start1":3972,"length1":614,"diffs":[[1,"        // Your chosen palette: index -> [R,G,B]\n        \n"]]},{"start1":4031,"length1":368,"diffs":[[1,""]]}]}]},{"timestamp":1756170932712,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"svgparse.ts","patch":[{"start1":3185,"length1":58,"diffs":[[1,"        let endPos = this.svgText.indexOf(\">\", startPos);\n"]]}]}]},{"timestamp":1756171579082,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"svgparse.ts","patch":[{"start1":4276,"length1":58,"diffs":[[1,"        let endPos = this.svgText.indexOf(\">\", startPos);\n"]]}]}]},{"timestamp":1756171581503,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":16,"length1":179,"diffs":[[1,""]]},{"start1":18,"length1":1,"diffs":[[1,""]]}]},{"type":"edited","filename":"svgparse.ts","patch":[{"start1":0,"length1":1,"diffs":[[1,""]]},{"start1":1084,"length1":414,"diffs":[[1,"            let rectPos = this.svgText.indexOf(\"<rect\", pos);\n            let circPos = this.svgText.indexOf(\"<circle\", pos);\n            let linePos = this.svgText.indexOf(\"<line\", pos);\n"]]},{"start1":1273,"length1":0,"diffs":[[1,"            // Find the next tag in order\n"]]},{"start1":1375,"length1":62,"diffs":[[1,""]]},{"start1":1713,"length1":488,"diffs":[[1,""]]},{"start1":2325,"length1":383,"diffs":[[1,""]]},{"start1":2378,"length1":58,"diffs":[[1,"        let endPos = this.svgText.indexOf(\">\", startPos);\n"]]},{"start1":4226,"length1":1,"diffs":[[1,""]]},{"start1":4276,"length1":147,"diffs":[[1,"        let endPos = this.svgText.indexOf(\",\", startPos);\n"]]},{"start1":4392,"length1":42,"diffs":[[1,""]]},{"start1":4494,"length1":463,"diffs":[[1,"        let tokens = d.trim().split(\",\");\n        let prevX = 0, prevY = 0;\n"]]},{"start1":4589,"length1":1,"diffs":[[1,""]]},{"start1":4660,"length1":95,"diffs":[[1,""]]},{"start1":4704,"length1":230,"diffs":[[1,"                let x = this.scaleX(parseFloat(tokens[i++]));\n                let y = this.scaleY(parseFloat(tokens[i++]));\n"]]},{"start1":5000,"length1":60,"diffs":[[1,""]]},{"start1":5014,"length1":1045,"diffs":[[1,""]]},{"start1":5024,"length1":1,"diffs":[[1,""]]},{"start1":5054,"length1":1,"diffs":[[1,""]]},{"start1":5104,"length1":58,"diffs":[[1,"        let endPos = this.svgText.indexOf(\">\", startPos);\n"]]}]}]},{"timestamp":1756252010241,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":195,"length1":179,"diffs":[[1,""]]},{"start1":197,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1756252015055,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":16,"length1":0,"diffs":[[1,"<path d=\"M 10 10 L 50 10 L 50 50 L 10 50 Z\" stroke=\"#FF0000\"/>\n<path d=\"M 20 20 h 40 v 40 h -40 Z\" stroke=\"#00FF00\"/>\n<path d=\"M 30 30 l 20 0 l 0 20 l -20 0 z\" stroke=\"#0000FF\"/>\n<path d=\"M 10 10 L 50 10 L 50 50 L 10 50 Z\" stroke=\"#FF0000\"/>\n<path d=\"M 20 20 h 40 v 40 h -40 Z\" stroke=\"#00FF00\"/>\n<path d=\"M 30 30 l 20 0 l 0 20 l -20 0 z\" stroke=\"#0000FF\"/>\n"]]}]},{"type":"edited","filename":"svgparse.ts","patch":[{"start1":10202,"length1":51,"diffs":[[1,""]]},{"start1":10253,"length1":103,"diffs":[[1,"            [255, 129, 53],  // 4 orange (#FF8135)\n            [0, 0, 0],       // 15 black (#000000)\n            [229, 205, 196], // 14 brown (#E5CDC4)\n"]]},{"start1":10460,"length1":373,"diffs":[[1,"            [0, 255, 255],   // 6 cyan-ish (#00FFFF)\n            [229, 205, 196]  // 13 new color (#E5CDC4)\n"]]},{"start1":10748,"length1":26,"diffs":[[1,""]]},{"start1":10774,"length1":53,"diffs":[[1,"            4,  // orange\n            15, // black\n            14, // brown\n"]]},{"start1":10879,"length1":192,"diffs":[[1,"            6,  // cyan-ish\n            13  // new color\n"]]}]}]},{"timestamp":1756252571808,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"svgparse.ts","patch":[{"start1":3018,"length1":72,"diffs":[[1,""]]},{"start1":4232,"length1":1158,"diffs":[[1,""]]},{"start1":12038,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1756253029958,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":16,"length1":207,"diffs":[[1,""]]},{"start1":18,"length1":38,"diffs":[[1,"`;\n\nlet parser = new SVGParser(rawSVG);\n"]]}]},{"type":"edited","filename":"svgparse.ts","patch":[{"start1":132,"length1":38,"diffs":[[1,""]]},{"start1":133,"length1":62,"diffs":[[1,"    constructor(svgText: string) {\n"]]},{"start1":301,"length1":59,"diffs":[[1,""]]},{"start1":5085,"length1":60,"diffs":[[1,"            let smallest = Math.min(d5, Math.min(d8,d12));\n"]]},{"start1":8900,"length1":1722,"diffs":[[1,""]]},{"start1":9229,"length1":617,"diffs":[[1,""]]},{"start1":9230,"length1":1664,"diffs":[[1,""]]},{"start1":9999,"length1":39,"diffs":[[1,"        let r = this.getAttr(tag,\"r\")\n"]]},{"start1":13268,"length1":1,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1756253647975,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"svgparse.ts","patch":[{"start1":11076,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1756253694094,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"svgparse.ts","patch":[{"start1":461,"length1":77,"diffs":[[1,""]]},{"start1":1623,"length1":110,"diffs":[[1,""]]},{"start1":1624,"length1":1,"diffs":[[1,""]]},{"start1":2572,"length1":224,"diffs":[[1,""]]},{"start1":3213,"length1":69,"diffs":[[1,""]]},{"start1":3256,"length1":722,"diffs":[[1,""]]},{"start1":11076,"length1":5,"diffs":[[1,""]]},{"start1":11077,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1756254289426,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":51,"diffs":[[1,"\n"]]},{"start1":16,"length1":27,"diffs":[[1,"<svg viewBox=\"0 0 100 100\">\n"]]},{"start1":117,"length1":76,"diffs":[[1,"    d=\"M 50,10\n       A 40,40 0 1,0 50,90\n       A 40,40 0 1,0 50,10\"\n"]]},{"start1":321,"length1":12,"diffs":[[1,""]]}]},{"type":"edited","filename":"svgparse.ts","patch":[{"start1":425,"length1":72,"diffs":[[1,""]]},{"start1":3737,"length1":1720,"diffs":[[1,""]]}]}]},{"timestamp":1756255065125,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":386,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1756255068000,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":119,"diffs":[[1,"let X  = 60;\nlet Y = 10;\ngame.onShade(function() {\nlet rawSVG = `\n<svg viewBox=\"0 0 10 100\">\n  <!-- Move to top-center (50,10), draw two half-circle arcs -->\n  <path\n    d=\"M ${X},${Y}\n       A 43,40 0 1,0 50,90\n       A 49,40 0 1,0 ${X},10\"\n    stroke=\"#FF2121\"\n  />\n</svg>\n`;\n"]]},{"start1":279,"length1":167,"diffs":[[1,""]]},{"start1":280,"length1":73,"diffs":[[1,"let parser = new SVGParser(rawSVG,8);\nlet Img = parser.render();\nscene.setBackgroundImage(Img);\nX++;\nY--;\np\n})"]]}]},{"type":"edited","filename":"svgparse.ts","patch":[{"start1":265,"length1":139,"diffs":[[1,"        this.img = image.create(160, 120);\n        this.viewBoxW = 160;\n        this.viewBoxH = 120;\n"]]},{"start1":1134,"length1":61,"diffs":[[1,"        return Math.round(x * 160 / this.viewBoxW);\n"]]},{"start1":1233,"length1":62,"diffs":[[1,"        return Math.round(y * 120 / this.viewBoxH);\n"]]}]}]},{"timestamp":1756255809047,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":320,"length1":50,"diffs":[[1,"scene.setBackgroundImage(parser.render())"]]}]}]},{"timestamp":1756255811962,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":12,"length1":17,"diffs":[[1,"<svg-L viewBox=\"0 0 100 100\">\n  <defs>\n    <circle id=\"dot\" cx=\"0\" cy=\"0\" r=\"5\" fill=\"#FF2121\"/>\n  </defs>\n"]]},{"start1":120,"length1":0,"diffs":[[1,"  <label name=\"start\"/>\n  <use href=\"#dot\" x=\"10\" y=\"50\"/>\n  <pause>200</pause>\n  <use href=\"#dot\" x=\"20\" y=\"50\"/>\n  <pause>200</pause>\n  <goto>start</goto>\n</svg-L>`\n\n"]]},{"start1":320,"length1":41,"diffs":[[1,"scene.setBackgroundImage(parser.render().design())"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":313,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"svgparse.ts","patch":[{"start1":6572,"length1":228,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1756169824102,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"SVG parser.\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1756171644840,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\nlet rawSVG = `\n\n\n`;\n\nlet parser = new SVGParser(rawSVG);\nlet Img = parser.render();\nscene.setBackgroundImage(Img);\n","README.md":" ","assets.json":"","svgparse.ts":"class SVGParser {\n    private svgText: string;\n    private img: Image;\n    private viewBoxW: number;\n    private viewBoxH: number;\n\n    constructor(svgText: string) {\n        this.svgText = svgText;\n        this.img = image.create(160, 120);\n        this.viewBoxW = 160;\n        this.viewBoxH = 120;\n        this.parseViewBox();\n    }\n\n    private parseViewBox() {\n        let vbPos = this.svgText.indexOf(\"viewBox=\");\n        if (vbPos >= 0) {\n            let quote1 = this.svgText.indexOf('\"', vbPos);\n            let quote2 = this.svgText.indexOf('\"', quote1 + 1);\n            let parts = this.svgText.substr(quote1 + 1, quote2).split(\" \");\n            if (parts.length == 4) {\n                this.viewBoxW = parseFloat(parts[2]);\n                this.viewBoxH = parseFloat(parts[3]);\n            }\n        }\n    }\n\n    private scaleX(x: number): number {\n        return Math.round(x * 160 / this.viewBoxW);\n    }\n\n    private scaleY(y: number): number {\n        return Math.round(y * 120 / this.viewBoxH);\n    }\n\n    render(): Image {\n        let pos = 0;\n        while (true) {\n            let rectPos = this.svgText.indexOf(\"<rect\", pos);\n            let circPos = this.svgText.indexOf(\"<circle\", pos);\n            let linePos = this.svgText.indexOf(\"<line\", pos);\n\n            // Find the next tag in order\n            let nextPos = -1;\n            let tagType = \"\";\n            if (rectPos != -1 && (nextPos == -1 || rectPos < nextPos)) { nextPos = rectPos; tagType = \"rect\"; }\n            if (circPos != -1 && (nextPos == -1 || circPos < nextPos)) { nextPos = circPos; tagType = \"circle\"; }\n            if (linePos != -1 && (nextPos == -1 || linePos < nextPos)) { nextPos = linePos; tagType = \"line\"; }\n\n            if (nextPos == -1) break;\n\n            if (tagType == \"rect\") pos = this.parseRect(nextPos);\n            else if (tagType == \"circle\") pos = this.parseCircle(nextPos);\n            else if (tagType == \"line\") pos = this.parseLine(nextPos);\n            else if (tagType == \"ellipse\") pos = this.parseEllipse(nextPos);\n            else if (tagType == \"polyline\") pos = this.parsePolyline(nextPos, false);\n            else if (tagType == \"polygon\") pos = this.parsePolyline(nextPos, true);\n            else if (tagType == \"path\") pos = this.parsePath(nextPos);\n        }\n        return this.img;\n    }\n\n    private parseEllipse(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let cx = this.getAttr(tag, \"cx\");\n        let cy = this.getAttr(tag, \"cy\");\n        let rx = this.getAttr(tag, \"rx\");\n        let ry = this.getAttr(tag, \"ry\");\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        // Approximate ellipse by drawing horizontal lines\n        for (let y = -ry; y <= ry; y++) {\n            let w = Math.round(rx * Math.sqrt(1 - (y * y) / (ry * ry)));\n            this.img.drawLine(\n                this.scaleX(cx - w), this.scaleY(cy + y),\n                this.scaleX(cx + w), this.scaleY(cy + y),\n                color\n            );\n        }\n        return endPos;\n    }\n\n    private parsePolyline(startPos: number, closed: boolean): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let pointsStr = this.getStringAttr(tag, \"points\");\n        let color = this.colorFromAttr(tag, \"stroke\");\n\n        let coords = pointsStr.trim().split(\",\");\n        for (let i = 0; i < coords.length - 2; i += 2) {\n            let x1 = this.scaleX(parseFloat(coords[i]));\n            let y1 = this.scaleY(parseFloat(coords[i + 1]));\n            let x2 = this.scaleX(parseFloat(coords[i + 2]));\n            let y2 = this.scaleY(parseFloat(coords[i + 3]));\n            this.img.drawLine(x1, y1, x2, y2, color);\n        }\n\n        if (closed && coords.length >= 4) {\n            let x1 = this.scaleX(parseFloat(coords[coords.length - 2]));\n            let y1 = this.scaleY(parseFloat(coords[coords.length - 1]));\n            let x2 = this.scaleX(parseFloat(coords[0]));\n            let y2 = this.scaleY(parseFloat(coords[1]));\n            this.img.drawLine(x1, y1, x2, y2, color);\n        }\n\n        return endPos;\n    }\n    private parsePath(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let d = this.getStringAttr(tag, \"d\");\n        let color = this.colorFromAttr(tag, \"stroke\");\n\n        let tokens = d.trim().split(\",\");\n        let prevX = 0, prevY = 0;\n        let i = 0;\n        while (i < tokens.length) {\n            let cmd = tokens[i++];\n            if (cmd == \"M\" || cmd == \"L\") {\n                let x = this.scaleX(parseFloat(tokens[i++]));\n                let y = this.scaleY(parseFloat(tokens[i++]));\n                if (cmd == \"L\") {\n                    this.img.drawLine(prevX, prevY, x, y, color);\n                }\n                prevX = x;\n                prevY = y;\n            }\n        }\n        return endPos;\n    }\n\n    private parseRect(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x = this.getAttr(tag, \"x\");\n        let y = this.getAttr(tag, \"y\");\n        let w = this.getAttr(tag, \"width\");\n        let h = this.getAttr(tag, \"height\");\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        this.img.fillRect(this.scaleX(x), this.scaleY(y), this.scaleX(w), this.scaleY(h), color);\n        return endPos;\n    }\n\n    private parseCircle(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let cx = this.getAttr(tag, \"cx\");\n        let cy = this.getAttr(tag, \"cy\");\n        let r = this.getAttr(tag,\"r\")\n        let color = this.colorFromAttr(tag, \"fill\");\n        this.img.fillCircle(this.scaleX(cx), this.scaleY(cy), Math.round(r * (160 / this.viewBoxW)), color);\n        return endPos;\n    }\n\n    private parseLine(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x1 = this.getAttr(tag, \"x1\");\n        let y1 = this.getAttr(tag, \"y1\");\n        let x2 = this.getAttr(tag, \"x2\");\n        let y2 = this.getAttr(tag, \"y2\");\n\n        let color = this.colorFromAttr(tag, \"stroke\");\n        this.img.drawLine(this.scaleX(x1), this.scaleY(y1), this.scaleX(x2), this.scaleY(y2), color);\n\n        return endPos;\n    }\n    // New: map an SVG hex color to your chosen palette\n    private colorFromAttr(tag: string, attrName: string): number {\n        let hex = this.getStringAttr(tag, attrName);\n        if (hex.length == 0) return 1; // default white if missing\n        if (hex.charAt(0) == '#') hex = hex.substr(1);\n\n        let r = parseInt(hex.substr(0, 2), 16);\n        let g = parseInt(hex.substr(2, 2), 16);\n        let b = parseInt(hex.substr(4, 2), 16);\n\n        // RGB values for closest-match calculation\n        const palette: number[][] = [\n            [255, 255, 255], // 1 white (#FFFFFF)\n            [255, 33, 33],   // 2 red (#FF2121)\n            [255, 147, 196], // 3 pink (#FF93C4)\n            [255, 246, 9],   // 5 yellow (#FFF609)\n            [255, 129, 53],  // 4 orange (#FF8135)\n            [0, 0, 0],       // 15 black (#000000)\n            [229, 205, 196], // 14 brown (#E5CDC4)\n            [0, 63, 173],    // 8 dark blue (#003FAD)\n            [0, 255, 255],   // 6 cyan-ish (#00FFFF)\n            [229, 205, 196]  // 13 new color (#E5CDC4)\n        ];\n\n        // Matching palette indexes in MakeCode Arcade\n        const paletteIndex: number[] = [\n            1,  // white\n            2,  // red\n            3,  // pink\n            5,  // yellow\n            4,  // orange\n            15, // black\n            14, // brown\n            8,  // dark blue\n            6,  // cyan-ish\n            13  // new color\n        ];\n\n        let bestIndex = 1;\n        let bestDist = 999999;\n        for (let i = 0; i < palette.length; i++) {\n            let dr = palette[i][0] - r;\n            let dg = palette[i][1] - g;\n            let db = palette[i][2] - b;\n            let dist = dr * dr + dg * dg + db * db;\n            if (dist < bestDist) {\n                bestDist = dist;\n                bestIndex = paletteIndex[i];\n            }\n        }\n        return bestIndex;\n    }\n\n    // Slightly refactored getAttr to get numbers\n    private getAttr(tag: string, name: string): number {\n        let valStr = this.getStringAttr(tag, name);\n        if (valStr.length > 0) return parseFloat(valStr);\n        return 0;\n    }\n\n    // New: get string attribute (for colors)\n    private getStringAttr(tag: string, name: string): string {\n        let pos = tag.indexOf(name + \"=\");\n        if (pos >= 0) {\n            let quote1 = tag.indexOf('\"', pos);\n            let quote2 = tag.indexOf('\"', quote1 + 1);\n            return tag.substr(quote1 + 1, quote2).trim();\n        }\n        return \"\";\n    }\n\n}","pxt.json":"{\n    \"name\": \"SVG parser.\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"svgparse.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756251925368,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\nlet rawSVG = `\n<path d=\"M 10 10 L 50 10 L 50 50 L 10 50 Z\" stroke=\"#FF0000\"/>\n<path d=\"M 20 20 h 40 v 40 h -40 Z\" stroke=\"#00FF00\"/>\n<path d=\"M 30 30 l 20 0 l 0 20 l -20 0 z\" stroke=\"#0000FF\"/>\n\n\n\n`;\n\nlet parser = new SVGParser(rawSVG);\nlet Img = parser.render();\nscene.setBackgroundImage(Img);\n","README.md":" ","assets.json":"","svgparse.ts":"\nclass SVGParser {\n    private svgText: string;\n    private img: Image;\n    private viewBoxW: number;\n    private viewBoxH: number;\n\n    constructor(svgText: string) {\n        this.svgText = svgText;\n        this.img = image.create(160, 120);\n        this.viewBoxW = 160;\n        this.viewBoxH = 120;\n        this.parseViewBox();\n    }\n\n    private parseViewBox() {\n        let vbPos = this.svgText.indexOf(\"viewBox=\");\n        if (vbPos >= 0) {\n            let quote1 = this.svgText.indexOf('\"', vbPos);\n            let quote2 = this.svgText.indexOf('\"', quote1 + 1);\n            let parts = this.svgText.substr(quote1 + 1, quote2).split(\" \");\n            if (parts.length == 4) {\n                this.viewBoxW = parseFloat(parts[2]);\n                this.viewBoxH = parseFloat(parts[3]);\n            }\n        }\n    }\n\n    private scaleX(x: number): number {\n        return Math.round(x * 160 / this.viewBoxW);\n    }\n\n    private scaleY(y: number): number {\n        return Math.round(y * 120 / this.viewBoxH);\n    }\n\n    render(): Image {\n        let pos = 0;\n        while (true) {\n            let rectPos = this.findTagPos(pos, \"rect\");\n            let circPos = this.findTagPos(pos, \"circle\");\n            let linePos = this.findTagPos(pos, \"line\");\n            let ellipsePos = this.findTagPos(pos, \"ellipse\");\n            let polylinePos = this.findTagPos(pos, \"polyline\");\n            let polygonPos = this.findTagPos(pos, \"polygon\");\n            let pathPos = this.findTagPos(pos, \"path\");\n\n            let nextPos = -1;\n            let tagType = \"\";\n\n            // Inline comparisons instead of nested function\n            if (rectPos != -1 && (nextPos == -1 || rectPos < nextPos)) { nextPos = rectPos; tagType = \"rect\"; }\n            if (circPos != -1 && (nextPos == -1 || circPos < nextPos)) { nextPos = circPos; tagType = \"circle\"; }\n            if (linePos != -1 && (nextPos == -1 || linePos < nextPos)) { nextPos = linePos; tagType = \"line\"; }\n            if (ellipsePos != -1 && (nextPos == -1 || ellipsePos < nextPos)) { nextPos = ellipsePos; tagType = \"ellipse\"; }\n            if (polylinePos != -1 && (nextPos == -1 || polylinePos < nextPos)) { nextPos = polylinePos; tagType = \"polyline\"; }\n            if (polygonPos != -1 && (nextPos == -1 || polygonPos < nextPos)) { nextPos = polygonPos; tagType = \"polygon\"; }\n            if (pathPos != -1 && (nextPos == -1 || pathPos < nextPos)) { nextPos = pathPos; tagType = \"path\"; }\n\n            if (nextPos == -1) break;\n\n            if (tagType == \"rect\") pos = this.parseRect(nextPos);\n            else if (tagType == \"circle\") pos = this.parseCircle(nextPos);\n            else if (tagType == \"line\") pos = this.parseLine(nextPos);\n            else if (tagType == \"ellipse\") pos = this.parseEllipse(nextPos);\n            else if (tagType == \"polyline\") pos = this.parsePolyline(nextPos, false);\n            else if (tagType == \"polygon\") pos = this.parsePolyline(nextPos, true);\n            else if (tagType == \"path\") pos = this.parsePath(nextPos);\n        }\n        return this.img;\n    }\n\n    // Helper to find tag position with or without namespace prefix\n    private findTagPos(fromPos: number, tagName: string): number {\n        let plain = this.svgText.indexOf(\"<\" + tagName, fromPos);\n        let ns = this.svgText.indexOf(\":\" + tagName, fromPos);\n        if (plain == -1) return ns;\n        if (ns == -1) return plain;\n        return plain < ns ? plain : ns;\n    }\n\n    private parseEllipse(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let cx = this.getAttr(tag, \"cx\");\n        let cy = this.getAttr(tag, \"cy\");\n        let rx = this.getAttr(tag, \"rx\");\n        let ry = this.getAttr(tag, \"ry\");\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        // Approximate ellipse by drawing horizontal lines\n        for (let y = -ry; y <= ry; y++) {\n            let w = Math.round(rx * Math.sqrt(1 - (y * y) / (ry * ry)));\n            this.img.drawLine(\n                this.scaleX(cx - w), this.scaleY(cy + y),\n                this.scaleX(cx + w), this.scaleY(cy + y),\n                color\n            );\n        }\n        return endPos;\n    }\n\n    private parsePolyline(startPos: number, closed: boolean): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let pointsStr = this.getStringAttr(tag, \"points\");\n        let color = this.colorFromAttr(tag, \"stroke\");\n\n        let coords = pointsStr.trim().split(\",\");\n        for (let i = 0; i < coords.length - 2; i += 2) {\n            let x1 = this.scaleX(parseFloat(coords[i]));\n            let y1 = this.scaleY(parseFloat(coords[i + 1]));\n            let x2 = this.scaleX(parseFloat(coords[i + 2]));\n            let y2 = this.scaleY(parseFloat(coords[i + 3]));\n            this.img.drawLine(x1, y1, x2, y2, color);\n        }\n\n        if (closed && coords.length >= 4) {\n            let x1 = this.scaleX(parseFloat(coords[coords.length - 2]));\n            let y1 = this.scaleY(parseFloat(coords[coords.length - 1]));\n            let x2 = this.scaleX(parseFloat(coords[0]));\n            let y2 = this.scaleY(parseFloat(coords[1]));\n            this.img.drawLine(x1, y1, x2, y2, color);\n        }\n\n        return endPos;\n    }\n\n    private parsePath(startPos: number): number {\n        // Find the end of the tag\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        if (endPos < 0) endPos = this.svgText.length;\n        let tag = this.svgText.substr(startPos, endPos);\n\n        // Get path data and stroke color\n        let d = this.getStringAttr(tag, \"d\");\n        let color = this.colorFromAttr(tag, \"stroke\");\n\n        // Tokenize: replace commas with spaces, then split on spaces\n        d = d.replace(\",\", \" \");\n        while (d.indexOf(\",\") >= 0) d = d.replace(\",\", \" \");\n        let rawTokens = d.trim().split(\" \");\n        let tokens: string[] = [];\n        for (let t of rawTokens) {\n            let tt = t.trim();\n            if (tt.length > 0) tokens.push(tt);\n        }\n\n        let prevX = 0;\n        let prevY = 0;\n        let startX = 0;\n        let startY = 0;\n        let i = 0;\n\n        while (i < tokens.length) {\n            let cmd = tokens[i++];\n            let isRelative = (cmd >= \"a\" && cmd <= \"z\");\n            cmd = cmd.toUpperCase();\n\n            if (cmd == \"M\" || cmd == \"L\") {\n                let x = parseFloat(tokens[i++]);\n                let y = parseFloat(tokens[i++]);\n                if (isRelative) { x += prevX; y += prevY; }\n                x = this.scaleX(x);\n                y = this.scaleY(y);\n                if (cmd == \"L\") {\n                    this.img.drawLine(prevX, prevY, x, y, color);\n                }\n                prevX = x;\n                prevY = y;\n                if (cmd == \"M\") { startX = x; startY = y; }\n            }\n            else if (cmd == \"H\") {\n                let x = parseFloat(tokens[i++]);\n                if (isRelative) x += prevX;\n                x = this.scaleX(x);\n                this.img.drawLine(prevX, prevY, x, prevY, color);\n                prevX = x;\n            }\n            else if (cmd == \"V\") {\n                let y = parseFloat(tokens[i++]);\n                if (isRelative) y += prevY;\n                y = this.scaleY(y);\n                this.img.drawLine(prevX, prevY, prevX, y, color);\n                prevY = y;\n            }\n            else if (cmd == \"Z\") {\n                // Close path\n                this.img.drawLine(prevX, prevY, startX, startY, color);\n                prevX = startX;\n                prevY = startY;\n            }\n            else {\n                // Unsupported command â€” skip numbers until next letter\n                while (i < tokens.length && !(tokens[i].length == 1 && tokens[i].toUpperCase() >= \"A\" && tokens[i].toUpperCase() <= \"Z\")) {\n                    i++;\n                }\n            }\n        }\n\n        return endPos;\n    }\n\n\n    private parseRect(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x = this.getAttr(tag, \"x\");\n        let y = this.getAttr(tag, \"y\");\n        let w = this.getAttr(tag, \"width\");\n        let h = this.getAttr(tag, \"height\");\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        this.img.fillRect(this.scaleX(x), this.scaleY(y), this.scaleX(w), this.scaleY(h), color);\n        return endPos;\n    }\n\n    private parseCircle(startPos: number): number {\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let cx = this.getAttr(tag, \"cx\");\n        let cy = this.getAttr(tag, \"cy\");\n        let r = this.getAttr(tag,\"r\")\n        let color = this.colorFromAttr(tag, \"fill\");\n        this.img.fillCircle(this.scaleX(cx), this.scaleY(cy), Math.round(r * (160 / this.viewBoxW)), color);\n        return endPos;\n    }\n\n    private parseLine(startPos: number): number {\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x1 = this.getAttr(tag, \"x1\");\n        let y1 = this.getAttr(tag, \"y1\");\n        let x2 = this.getAttr(tag, \"x2\");\n        let y2 = this.getAttr(tag, \"y2\");\n\n        let color = this.colorFromAttr(tag, \"stroke\");\n        this.img.drawLine(this.scaleX(x1), this.scaleY(y1), this.scaleX(x2), this.scaleY(y2), color);\n\n        return endPos;\n    }\n    // New: map an SVG hex color to your chosen palette\n    private colorFromAttr(tag: string, attrName: string): number {\n        let hex = this.getStringAttr(tag, attrName);\n        if (hex.length == 0) return 1; // default white if missing\n        if (hex.charAt(0) == '#') hex = hex.substr(1);\n\n        let r = parseInt(hex.substr(0, 2), 16);\n        let g = parseInt(hex.substr(2, 2), 16);\n        let b = parseInt(hex.substr(4, 2), 16);\n\n        // RGB values for closest-match calculation\n        const palette: number[][] = [\n            [255, 255, 255], // 1 white (#FFFFFF)\n            [255, 33, 33],   // 2 red (#FF2121)\n            [255, 147, 196], // 3 pink (#FF93C4)\n            [255, 246, 9],   // 5 yellow (#FFF609)\n            [255, 129, 53],  // 4 orange (#FF8135)\n            [0, 0, 0],       // 15 black (#000000)\n            [229, 205, 196], // 14 brown (#E5CDC4)\n            [0, 63, 173],    // 8 dark blue (#003FAD)\n            [0, 255, 255],   // 6 cyan-ish (#00FFFF)\n            [229, 205, 196]  // 13 new color (#E5CDC4)\n        ];\n\n        // Matching palette indexes in MakeCode Arcade\n        const paletteIndex: number[] = [\n            1,  // white\n            2,  // red\n            3,  // pink\n            5,  // yellow\n            4,  // orange\n            15, // black\n            14, // brown\n            8,  // dark blue\n            6,  // cyan-ish\n            13  // new color\n        ];\n\n        let bestIndex = 1;\n        let bestDist = 999999;\n        for (let i = 0; i < palette.length; i++) {\n            let dr = palette[i][0] - r;\n            let dg = palette[i][1] - g;\n            let db = palette[i][2] - b;\n            let dist = dr * dr + dg * dg + db * db;\n            if (dist < bestDist) {\n                bestDist = dist;\n                bestIndex = paletteIndex[i];\n            }\n        }\n        return bestIndex;\n    }\n\n    // Slightly refactored getAttr to get numbers\n    private getAttr(tag: string, name: string): number {\n        let valStr = this.getStringAttr(tag, name);\n        if (valStr.length > 0) return parseFloat(valStr);\n        return 0;\n    }\n\n    // New: get string attribute (for colors)\n    private getStringAttr(tag: string, name: string): string {\n        let pos = tag.indexOf(name + \"=\");\n        if (pos >= 0) {\n            let quote1 = tag.indexOf('\"', pos);\n            let quote2 = tag.indexOf('\"', quote1 + 1);\n            return tag.substr(quote1 + 1, quote2).trim();\n        }\n        return \"\";\n    }\n\n}","pxt.json":"{\n    \"name\": \"SVG parser.\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"svgparse.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756253768255,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\nlet rawSVG = `\n<svg viewBox=\"0 0 100 100\">\n  <!-- Move to top-center (50,10), draw two half-circle arcs -->\n  <path\n    d=\"M 50,10\n       A 40,40 0 1,0 50,90\n       A 40,40 0 1,0 50,10\"\n    stroke=\"#FF2121\"\n  />\n</svg>\n`;\n\n\nlet parser = new SVGParser(rawSVG,8);\nlet Img = parser.render();\nscene.setBackgroundImage(Img);\n","README.md":" ","assets.json":"","svgparse.ts":"\nclass SVGParser {\n    private svgText: string;\n    private img: Image;\n    private viewBoxW: number;\n    private viewBoxH: number;\n    private SmoothCurveAccuracy = 10;\n\n    constructor(svgText: string, SmoothCurveSteps?: number) {\n        this.svgText = svgText;\n        this.img = image.create(160, 120);\n        this.viewBoxW = 160;\n        this.viewBoxH = 120;\n        this.SmoothCurveAccuracy = SmoothCurveSteps || 10;\n        this.parseViewBox();\n    }\n\n    get smoothCurveSteps() {\n        return this.SmoothCurveAccuracy;\n    }\n\n    private parseViewBox() {\n        let vbPos = this.svgText.indexOf(\"viewBox=\");\n        if (vbPos >= 0) {\n            let quote1 = this.svgText.indexOf('\"', vbPos);\n            let quote2 = this.svgText.indexOf('\"', quote1 + 1);\n            let parts = this.svgText.substr(quote1 + 1, quote2).split(\" \");\n            if (parts.length == 4) {\n                this.viewBoxW = parseFloat(parts[2]);\n                this.viewBoxH = parseFloat(parts[3]);\n            }\n        }\n    }\n\n    private scaleX(x: number): number {\n        return Math.round(x * 160 / this.viewBoxW);\n    }\n\n    private scaleY(y: number): number {\n        return Math.round(y * 120 / this.viewBoxH);\n    }\n\n    render(): Image {\n        let pos = 0;\n        while (true) {\n            let rectPos = this.findTagPos(pos, \"rect\");\n            let circPos = this.findTagPos(pos, \"circle\");\n            let linePos = this.findTagPos(pos, \"line\");\n            let ellipsePos = this.findTagPos(pos, \"ellipse\");\n            let polylinePos = this.findTagPos(pos, \"polyline\");\n            let polygonPos = this.findTagPos(pos, \"polygon\");\n            let pathPos = this.findTagPos(pos, \"path\");\n\n            let nextPos = -1;\n            let tagType = \"\";\n\n            // Inline comparisons instead of nested function\n            if (rectPos != -1 && (nextPos == -1 || rectPos < nextPos)) { nextPos = rectPos; tagType = \"rect\"; }\n            if (circPos != -1 && (nextPos == -1 || circPos < nextPos)) { nextPos = circPos; tagType = \"circle\"; }\n            if (linePos != -1 && (nextPos == -1 || linePos < nextPos)) { nextPos = linePos; tagType = \"line\"; }\n            if (ellipsePos != -1 && (nextPos == -1 || ellipsePos < nextPos)) { nextPos = ellipsePos; tagType = \"ellipse\"; }\n            if (polylinePos != -1 && (nextPos == -1 || polylinePos < nextPos)) { nextPos = polylinePos; tagType = \"polyline\"; }\n            if (polygonPos != -1 && (nextPos == -1 || polygonPos < nextPos)) { nextPos = polygonPos; tagType = \"polygon\"; }\n            if (pathPos != -1 && (nextPos == -1 || pathPos < nextPos)) { nextPos = pathPos; tagType = \"path\"; }\n\n            if (nextPos == -1) break;\n\n            if (tagType == \"rect\") pos = this.parseRect(nextPos);\n            else if (tagType == \"circle\") pos = this.parseCircle(nextPos);\n            else if (tagType == \"line\") pos = this.parseLine(nextPos);\n            else if (tagType == \"ellipse\") pos = this.parseEllipse(nextPos);\n            else if (tagType == \"polyline\") pos = this.parsePolyline(nextPos, false);\n            else if (tagType == \"polygon\") pos = this.parsePolyline(nextPos, true);\n            else if (tagType == \"path\") pos = this.parsePath(nextPos);\n            else if (tagType == \"text\") pos = this.parseText(nextPos);\n\n        }\n        return this.img;\n    }\n\n    // Helper to find tag position with or without namespace prefix\n    private findTagPos(fromPos: number, tagName: string): number {\n        let plain = this.svgText.indexOf(\"<\" + tagName, fromPos);\n        let ns = this.svgText.indexOf(\":\" + tagName, fromPos);\n        if (plain == -1) return ns;\n        if (ns == -1) return plain;\n        return plain < ns ? plain : ns;\n    }\n\n    private parseEllipse(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let cx = this.getAttr(tag, \"cx\");\n        let cy = this.getAttr(tag, \"cy\");\n        let rx = this.getAttr(tag, \"rx\");\n        let ry = this.getAttr(tag, \"ry\");\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        // Approximate ellipse by drawing horizontal lines\n        for (let y = -ry; y <= ry; y++) {\n            let w = Math.round(rx * Math.sqrt(1 - (y * y) / (ry * ry)));\n            this.img.drawLine(\n                this.scaleX(cx - w), this.scaleY(cy + y),\n                this.scaleX(cx + w), this.scaleY(cy + y),\n                color\n            );\n        }\n        return endPos;\n    }\n\n    private parseText(startPos: number): number {\n        let endPos = this.svgText.indexOf(\"</text>\", startPos);\n        if (endPos < 0) return this.svgText.length;\n\n        let tagEnd = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, tagEnd + 1);\n        let content = this.svgText.substr(tagEnd + 1, endPos).trim();\n\n        let x = this.scaleX(this.getAttr(tag, \"x\"));\n        let y = this.scaleY(this.getAttr(tag, \"y\"));\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        let fontSize = this.getAttr(tag, \"font-size\");\n        let font = image.font8; // default\n\n        if (fontSize > 0) {\n            let d5 = Math.abs(fontSize - 5);\n            let d8 = Math.abs(fontSize - 8);\n            let d12 = Math.abs(fontSize - 12);\n            let smallest = Math.min(d5, Math.min(d8, d12));\n\n            if (smallest == d5) {\n                font = image.font5;\n            } else if (smallest == d8) {\n                font = image.font8;\n            } else {\n                font = image.font12;\n            }\n        }\n\n\n        this.img.print(content, x, y, color, font);\n        return endPos + 7;\n    }\n\n    private parsePolyline(startPos: number, closed: boolean): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let pointsStr = this.getStringAttr(tag, \"points\");\n        let color = this.colorFromAttr(tag, \"stroke\");\n\n        let coords = pointsStr.trim().split(\",\");\n        for (let i = 0; i < coords.length - 2; i += 2) {\n            let x1 = this.scaleX(parseFloat(coords[i]));\n            let y1 = this.scaleY(parseFloat(coords[i + 1]));\n            let x2 = this.scaleX(parseFloat(coords[i + 2]));\n            let y2 = this.scaleY(parseFloat(coords[i + 3]));\n            this.img.drawLine(x1, y1, x2, y2, color);\n        }\n\n        if (closed && coords.length >= 4) {\n            let x1 = this.scaleX(parseFloat(coords[coords.length - 2]));\n            let y1 = this.scaleY(parseFloat(coords[coords.length - 1]));\n            let x2 = this.scaleX(parseFloat(coords[0]));\n            let y2 = this.scaleY(parseFloat(coords[1]));\n            this.img.drawLine(x1, y1, x2, y2, color);\n        }\n\n        return endPos;\n    }\n\n    private parsePath(startPos: number): number {\n        // Find the end of the tag\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        if (endPos < 0) endPos = this.svgText.length;\n        let tag = this.svgText.substr(startPos, endPos);\n\n        // Get path data and stroke color\n        let d = this.getStringAttr(tag, \"d\");\n        let color = this.colorFromAttr(tag, \"stroke\");\n\n        // Tokenize: replace commas with spaces, then split on spaces\n        d = d.replace(\",\", \" \");\n        while (d.indexOf(\",\") >= 0) d = d.replace(\",\", \" \");\n        let rawTokens = d.trim().split(\" \");\n        let tokens: string[] = [];\n        for (let t of rawTokens) {\n            let tt = t.trim();\n            if (tt.length > 0) tokens.push(tt);\n        }\n\n        let prevX = 0;\n        let prevY = 0;\n        let startX = 0;\n        let startY = 0;\n        let i = 0;\n\n        while (i < tokens.length) {\n            let cmd = tokens[i++];\n            let isRelative = (cmd >= \"a\" && cmd <= \"z\");\n            cmd = cmd.toUpperCase();\n\n            if (cmd == \"M\" || cmd == \"L\") {\n                let x = parseFloat(tokens[i++]);\n                let y = parseFloat(tokens[i++]);\n                if (isRelative) { x += prevX; y += prevY; }\n                x = this.scaleX(x);\n                y = this.scaleY(y);\n                if (cmd == \"L\") {\n                    this.img.drawLine(prevX, prevY, x, y, color);\n                }\n                prevX = x;\n                prevY = y;\n                if (cmd == \"M\") { startX = x; startY = y; }\n            }\n            else if (cmd == \"H\") {\n                let x = parseFloat(tokens[i++]);\n                if (isRelative) x += prevX;\n                x = this.scaleX(x);\n                this.img.drawLine(prevX, prevY, x, prevY, color);\n                prevX = x;\n            }\n            else if (cmd == \"V\") {\n                let y = parseFloat(tokens[i++]);\n                if (isRelative) y += prevY;\n                y = this.scaleY(y);\n                this.img.drawLine(prevX, prevY, prevX, y, color);\n                prevY = y;\n            }\n            else if (cmd == \"Z\") {\n                // Close path\n                this.img.drawLine(prevX, prevY, startX, startY, color);\n                prevX = startX;\n                prevY = startY;\n            }\n            else if (cmd == \"C\") {\n                let x1 = this.scaleX(parseFloat(tokens[i++]));\n                let y1 = this.scaleY(parseFloat(tokens[i++]));\n                let x2 = this.scaleX(parseFloat(tokens[i++]));\n                let y2 = this.scaleY(parseFloat(tokens[i++]));\n                let x = this.scaleX(parseFloat(tokens[i++]));\n                let y = this.scaleY(parseFloat(tokens[i++]));\n\n                this.drawCubicBezier(prevX, prevY, x1, y1, x2, y2, x, y, color);\n                prevX = x;\n                prevY = y;\n            }\n            else if (cmd == \"Q\") {\n                let x1 = this.scaleX(parseFloat(tokens[i++]));\n                let y1 = this.scaleY(parseFloat(tokens[i++]));\n                let x = this.scaleX(parseFloat(tokens[i++]));\n                let y = this.scaleY(parseFloat(tokens[i++]));\n\n                this.drawQuadraticBezier(prevX, prevY, x1, y1, x, y, color);\n                prevX = x;\n                prevY = y;\n            }\n            else if (cmd == \"A\") {\n                let rx = parseFloat(tokens[i++]);\n                let ry = parseFloat(tokens[i++]);\n                let rotation = parseFloat(tokens[i++]); // ignored\n                let largeArc = parseInt(tokens[i++]);   // ignored\n                let sweep = parseInt(tokens[i++]);      // ignored\n                let x = this.scaleX(parseFloat(tokens[i++]));\n                let y = this.scaleY(parseFloat(tokens[i++]));\n\n                // Approximate arc as circular\n                let r = Math.min(rx, ry) * (160 / this.viewBoxW); // scale radius\n                this.drawArc(prevX, prevY, x, y, Math.round(r), color);\n                prevX = x;\n                prevY = y;\n            }\n            else {\n                // Unsupported command â€” skip numbers until next letter\n                while (i < tokens.length && !(tokens[i].length == 1 && tokens[i].toUpperCase() >= \"A\" && tokens[i].toUpperCase() <= \"Z\")) {\n                    i++;\n                }\n            }\n        }\n\n        return endPos;\n    }\n\n    \n\n    private drawQuadraticBezier(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, color: number) {\n        let steps = this.SmoothCurveAccuracy;\n        let prevX = x0;\n        let prevY = y0;\n        for (let t = 0; t <= steps; t++) {\n            let u = t / steps;\n            let x = (1 - u) * (1 - u) * x0 + 2 * (1 - u) * u * x1 + u * u * x2;\n            let y = (1 - u) * (1 - u) * y0 + 2 * (1 - u) * u * y1 + u * u * y2;\n            this.img.drawLine(prevX, prevY, Math.round(x), Math.round(y), color);\n            prevX = Math.round(x);\n            prevY = Math.round(y);\n        }\n    }\n\n    private drawArc(x0: number, y0: number, x1: number, y1: number, r: number, color: number) {\n        let steps = this.SmoothCurveAccuracy;\n        let cx = (x0 + x1) / 2;\n        let cy = (y0 + y1) / 2;\n        let angleStart = Math.atan2(y0 - cy, x0 - cx);\n        let angleEnd = Math.atan2(y1 - cy, x1 - cx);\n\n        // Ensure angleEnd > angleStart\n        if (angleEnd < angleStart) angleEnd += 2 * Math.PI;\n\n        let prevX = x0;\n        let prevY = y0;\n        for (let t = 1; t <= steps; t++) {\n            let angle = angleStart + (angleEnd - angleStart) * (t / steps);\n            let x = cx + r * Math.cos(angle);\n            let y = cy + r * Math.sin(angle);\n            this.img.drawLine(prevX, prevY, Math.round(x), Math.round(y), color);\n            prevX = Math.round(x);\n            prevY = Math.round(y);\n        }\n    }\n\n    private drawCubicBezier(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, color: number) {\n        let steps = this.SmoothCurveAccuracy;\n        let prevX = x0;\n        let prevY = y0;\n        for (let t = 0; t <= steps; t++) {\n            let u = t / steps;\n            let x = Math.pow(1 - u, 3) * x0 +\n                3 * Math.pow(1 - u, 2) * u * x1 +\n                3 * (1 - u) * u * u * x2 +\n                u * u * u * x3;\n            let y = Math.pow(1 - u, 3) * y0 +\n                3 * Math.pow(1 - u, 2) * u * y1 +\n                3 * (1 - u) * u * u * y2 +\n                u * u * u * y3;\n            this.img.drawLine(prevX, prevY, Math.round(x), Math.round(y), color);\n            prevX = Math.round(x);\n            prevY = Math.round(y);\n        }\n    }\n\n    private parseRect(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x = this.getAttr(tag, \"x\");\n        let y = this.getAttr(tag, \"y\");\n        let w = this.getAttr(tag, \"width\");\n        let h = this.getAttr(tag, \"height\");\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        this.img.fillRect(this.scaleX(x), this.scaleY(y), this.scaleX(w), this.scaleY(h), color);\n        return endPos;\n    }\n\n    private parseCircle(startPos: number): number {\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let cx = this.getAttr(tag, \"cx\");\n        let cy = this.getAttr(tag, \"cy\");\n        let r = this.getAttr(tag, \"r\")\n        let color = this.colorFromAttr(tag, \"fill\");\n        this.img.fillCircle(this.scaleX(cx), this.scaleY(cy), Math.round(r * (160 / this.viewBoxW)), color);\n        return endPos;\n    }\n\n    private parseLine(startPos: number): number {\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x1 = this.getAttr(tag, \"x1\");\n        let y1 = this.getAttr(tag, \"y1\");\n        let x2 = this.getAttr(tag, \"x2\");\n        let y2 = this.getAttr(tag, \"y2\");\n\n        let color = this.colorFromAttr(tag, \"stroke\");\n        this.img.drawLine(this.scaleX(x1), this.scaleY(y1), this.scaleX(x2), this.scaleY(y2), color);\n\n        return endPos;\n    }\n    // New: map an SVG hex color to your chosen palette\n    private colorFromAttr(tag: string, attrName: string): number {\n        let hex = this.getStringAttr(tag, attrName);\n        if (hex.length == 0) return 1; // default white if missing\n        if (hex.charAt(0) == '#') hex = hex.substr(1);\n\n        let r = parseInt(hex.substr(0, 2), 16);\n        let g = parseInt(hex.substr(2, 2), 16);\n        let b = parseInt(hex.substr(4, 2), 16);\n\n        // RGB values for closest-match calculation\n        const palette: number[][] = [\n            [255, 255, 255], // 1 white (#FFFFFF)\n            [255, 33, 33],   // 2 red (#FF2121)\n            [255, 147, 196], // 3 pink (#FF93C4)\n            [255, 129, 53],  // 4 orange (#FF8135)\n            [255, 246, 9],   // 5 yellow (#FFF609)\n            [36, 156, 170],  // 6 cyan-ish (#249CAA)\n            [120, 220, 82],  // 7 green (#78DC52)\n            [0, 63, 173],    // 8 dark blue (#003FAD)\n            [135, 242, 255], // 9 light blue (#87F2FF)\n            [142, 46, 196],  // 10 purple (#8E2EC4)\n            [164, 131, 159], // 11 mauve (#A4839F)\n            [92, 64, 156],   // 12 indigo (#5C409C)\n            [229, 205, 196], // 13 pale brown (#E5CDC4)\n            [145, 70, 61],   // 14 deep brown (#91463D)\n            [0, 0, 0]        // 15 black (#000000)\n        ];\n\n        // Matching palette indexes in MakeCode Arcade\n        const paletteIndex: number[] = [\n            1,  // white\n            2,  // red\n            3,  // pink\n            4,  // orange\n            5,  // yellow\n            6,  // cyan-ish\n            7,  // green\n            8,  // dark blue\n            9,  // light blue\n            10, // purple\n            11, // mauve\n            12, // indigo\n            13, // pale brown\n            14, // deep brown\n            15  // black\n        ];\n\n        let bestIndex = 1;\n        let bestDist = 999999;\n        for (let i = 0; i < palette.length; i++) {\n            let dr = palette[i][0] - r;\n            let dg = palette[i][1] - g;\n            let db = palette[i][2] - b;\n            let dist = dr * dr + dg * dg + db * db;\n            if (dist < bestDist) {\n                bestDist = dist;\n                bestIndex = paletteIndex[i];\n            }\n        }\n        return bestIndex;\n    }\n\n    // Slightly refactored getAttr to get numbers\n    private getAttr(tag: string, name: string): number {\n        let valStr = this.getStringAttr(tag, name);\n        if (valStr.length > 0) return parseFloat(valStr);\n        return 0;\n\n    }\n\n    // New: get string attribute (for colors)\n    private getStringAttr(tag: string, name: string): string {\n        let pos = tag.indexOf(name + \"=\");\n        if (pos >= 0) {\n            let quote1 = tag.indexOf('\"', pos);\n            let quote2 = tag.indexOf('\"', quote1 + 1);\n            return tag.substr(quote1 + 1, quote2).trim();\n        }\n        return \"\";\n    }\n\n}","pxt.json":"{\n    \"name\": \"SVG parser.\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"svgparse.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756255809047,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"let svg = `\n<svg-L viewBox=\"0 0 100 100\">\n  <defs>\n    <circle id=\"dot\" cx=\"0\" cy=\"0\" r=\"5\" fill=\"#FF2121\"/>\n  </defs>\n\n  <label name=\"start\"/>\n  <use href=\"#dot\" x=\"10\" y=\"50\"/>\n  <pause>200</pause>\n  <use href=\"#dot\" x=\"20\" y=\"50\"/>\n  <pause>200</pause>\n  <goto>start</goto>\n</svg-L>`\n\nlet parser = new SVGParser(svg)\nscene.setBackgroundImage(parser.render())","README.md":" ","assets.json":"","svgparse.ts":"\nclass SVGParser {\n    private svgText: string;\n    private img: Image;\n    private viewBoxW: number;\n    private viewBoxH: number;\n    private SmoothCurveAccuracy = 10;\n\n    constructor(svgText: string, SmoothCurveSteps?: number) {\n        this.svgText = svgText;\n        this.img = image.create(screen.width, screen.height);\n        this.viewBoxW = screen.width;\n        this.viewBoxH = screen.height;\n        this.SmoothCurveAccuracy = SmoothCurveSteps || 10;\n        const defs = this.extractDefs();\n        this.expandUses(defs);\n        this.parseViewBox();\n    }\n\n    get smoothCurveSteps() {\n        return this.SmoothCurveAccuracy;\n    }\n\n    private parseViewBox() {\n        let vbPos = this.svgText.indexOf(\"viewBox=\");\n        if (vbPos >= 0) {\n            let quote1 = this.svgText.indexOf('\"', vbPos);\n            let quote2 = this.svgText.indexOf('\"', quote1 + 1);\n            let parts = this.svgText.substr(quote1 + 1, quote2).split(\" \");\n            if (parts.length == 4) {\n                this.viewBoxW = parseFloat(parts[2]);\n                this.viewBoxH = parseFloat(parts[3]);\n            }\n        }\n    }\n\n    private scaleX(x: number): number {\n        return Math.round(x * screen.width / this.viewBoxW);\n    }\n\n    private scaleY(y: number): number {\n        return Math.round(y * screen.height / this.viewBoxH);\n    }\n\n    render(): Image {\n        let pos = 0;\n        while (true) {\n            let rectPos = this.findTagPos(pos, \"rect\");\n            let circPos = this.findTagPos(pos, \"circle\");\n            let linePos = this.findTagPos(pos, \"line\");\n            let ellipsePos = this.findTagPos(pos, \"ellipse\");\n            let polylinePos = this.findTagPos(pos, \"polyline\");\n            let polygonPos = this.findTagPos(pos, \"polygon\");\n            let pathPos = this.findTagPos(pos, \"path\");\n            let textPos = this.findTagPos(pos, \"text\");\n            let groupPos = this.findTagPos(pos, \"g\");\n\n\n            let nextPos = -1;\n            let tagType = \"\";\n\n            // Inline comparisons instead of nested function\n            if (rectPos != -1 && (nextPos == -1 || rectPos < nextPos)) { nextPos = rectPos; tagType = \"rect\"; }\n            if (circPos != -1 && (nextPos == -1 || circPos < nextPos)) { nextPos = circPos; tagType = \"circle\"; }\n            if (linePos != -1 && (nextPos == -1 || linePos < nextPos)) { nextPos = linePos; tagType = \"line\"; }\n            if (ellipsePos != -1 && (nextPos == -1 || ellipsePos < nextPos)) { nextPos = ellipsePos; tagType = \"ellipse\"; }\n            if (polylinePos != -1 && (nextPos == -1 || polylinePos < nextPos)) { nextPos = polylinePos; tagType = \"polyline\"; }\n            if (polygonPos != -1 && (nextPos == -1 || polygonPos < nextPos)) { nextPos = polygonPos; tagType = \"polygon\"; }\n            if (pathPos != -1 && (nextPos == -1 || pathPos < nextPos)) { nextPos = pathPos; tagType = \"path\"; }\n            if (textPos != -1 && (nextPos == -1 || textPos < nextPos)) { nextPos = textPos; tagType = \"text\"; }\n            if (groupPos != -1 && (nextPos == -1 || groupPos < nextPos)) { nextPos = groupPos; tagType = \"g\"; }\n\n            if (nextPos == -1) break;\n\n            if (tagType == \"rect\") pos = this.parseRect(nextPos);\n            else if (tagType == \"circle\") pos = this.parseCircle(nextPos);\n            else if (tagType == \"line\") pos = this.parseLine(nextPos);\n            else if (tagType == \"ellipse\") pos = this.parseEllipse(nextPos);\n            else if (tagType == \"polyline\") pos = this.parsePolyline(nextPos, false);\n            else if (tagType == \"polygon\") pos = this.parsePolyline(nextPos, true);\n            else if (tagType == \"path\") pos = this.parsePath(nextPos);\n            else if (tagType == \"text\") pos = this.parseText(nextPos);\n            else if (tagType == \"g\") pos = this.parseGroup(nextPos);\n\n        }\n        return this.img;\n    }\n\n    private extractDefs(): { [id: string]: string } {\n        let defs: { [id: string]: string } = {};\n        let pos = 0;\n        while (true) {\n            let defStart = this.svgText.indexOf(\"<\", pos);\n            if (defStart == -1) break;\n            let defEnd = this.svgText.indexOf(\">\", defStart);\n            if (defEnd == -1) break;\n\n            let tag = this.svgText.substr(defStart, defEnd + 1);\n            if (tag.indexOf(\"<circle\") >= 0 || tag.indexOf(\"<rect\") >= 0 || tag.indexOf(\"<path\") >= 0) {\n                let id = this.getStringAttr(tag, \"id\");\n                if (id.length > 0) {\n                    defs[id] = tag;\n                }\n            }\n            pos = defEnd + 1;\n        }\n        return defs;\n    }\n\n    private expandUses(defs: { [id: string]: string }): void {\n        let pos = 0;\n        let result = \"\";\n        while (true) {\n            let usePos = this.svgText.indexOf(\"<use\", pos);\n            if (usePos == -1) {\n                result += this.svgText.substr(pos);\n                break;\n            }\n\n            let tagEnd = this.svgText.indexOf(\">\", usePos);\n            let tag = this.svgText.substr(usePos, tagEnd + 1);\n            let href = this.getStringAttr(tag, \"href\");\n            let x = this.getAttr(tag, \"x\");\n            let y = this.getAttr(tag, \"y\");\n\n            let def = defs[href.substr(1)]; // remove '#' from href\n            if (def) {\n                // Inject x/y as transform or override attributes\n                let injected = def.replace(\">\", ` x=\"${x}\" y=\"${y}\">`);\n                result += this.svgText.substr(pos, usePos) + injected;\n            }\n\n            pos = tagEnd + 1;\n        }\n\n        this.svgText = result;\n    }\n\n    private parseGroup(startPos: number): number {\n        let endTag = \"</g>\";\n        let endPos = this.svgText.indexOf(endTag, startPos);\n        if (endPos < 0) return this.svgText.length;\n\n        let tagEnd = this.svgText.indexOf(\">\", startPos);\n        if (tagEnd < 0 || tagEnd > endPos) tagEnd = endPos;\n\n        let groupContent = this.svgText.substr(tagEnd + 1, endPos);\n\n        // Create a temporary parser for the group content\n        let subParser = new SVGParser(groupContent, this.SmoothCurveAccuracy);\n        let subImage = subParser.render();\n\n        // Merge subImage into main image\n        this.img.drawImage(subImage, 0, 0);\n        subParser = null;\n        return endPos + endTag.length;\n    }\n\n    // Helper to find tag position with or without namespace prefix\n    private findTagPos(fromPos: number, tagName: string): number {\n        let plain = this.svgText.indexOf(\"<\" + tagName, fromPos);\n        let ns = this.svgText.indexOf(\":\" + tagName, fromPos);\n        if (plain == -1) return ns;\n        if (ns == -1) return plain;\n        return plain < ns ? plain : ns;\n    }\n\n    private parseEllipse(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let cx = this.getAttr(tag, \"cx\");\n        let cy = this.getAttr(tag, \"cy\");\n        let rx = this.getAttr(tag, \"rx\");\n        let ry = this.getAttr(tag, \"ry\");\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        // Approximate ellipse by drawing horizontal lines\n        for (let y = -ry; y <= ry; y++) {\n            let w = Math.round(rx * Math.sqrt(1 - (y * y) / (ry * ry)));\n            this.img.drawLine(\n                this.scaleX(cx - w), this.scaleY(cy + y),\n                this.scaleX(cx + w), this.scaleY(cy + y),\n                color\n            );\n        }\n        return endPos;\n    }\n\n    private parseText(startPos: number): number {\n        let endPos = this.svgText.indexOf(\"</text>\", startPos);\n        if (endPos < 0) return this.svgText.length;\n\n        let tagEnd = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, tagEnd + 1);\n        let content = this.svgText.substr(tagEnd + 1, endPos).trim();\n\n        let x = this.scaleX(this.getAttr(tag, \"x\"));\n        let y = this.scaleY(this.getAttr(tag, \"y\"));\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        let fontSize = this.getAttr(tag, \"font-size\");\n        let font = image.font8; // default\n\n        if (fontSize > 0) {\n            let d5 = Math.abs(fontSize - 5);\n            let d8 = Math.abs(fontSize - 8);\n            let d12 = Math.abs(fontSize - 12);\n            let smallest = Math.min(d5, Math.min(d8, d12));\n\n            if (smallest == d5) {\n                font = image.font5;\n            } else if (smallest == d8) {\n                font = image.font8;\n            } else {\n                font = image.font12;\n            }\n        }\n\n\n        this.img.print(content, x, y, color, font);\n        return endPos + 7;\n    }\n\n    private parsePolyline(startPos: number, closed: boolean): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let pointsStr = this.getStringAttr(tag, \"points\");\n        let color = this.colorFromAttr(tag, \"stroke\");\n\n        let coords = pointsStr.trim().split(\",\");\n        for (let i = 0; i < coords.length - 2; i += 2) {\n            let x1 = this.scaleX(parseFloat(coords[i]));\n            let y1 = this.scaleY(parseFloat(coords[i + 1]));\n            let x2 = this.scaleX(parseFloat(coords[i + 2]));\n            let y2 = this.scaleY(parseFloat(coords[i + 3]));\n            this.img.drawLine(x1, y1, x2, y2, color);\n        }\n\n        if (closed && coords.length >= 4) {\n            let x1 = this.scaleX(parseFloat(coords[coords.length - 2]));\n            let y1 = this.scaleY(parseFloat(coords[coords.length - 1]));\n            let x2 = this.scaleX(parseFloat(coords[0]));\n            let y2 = this.scaleY(parseFloat(coords[1]));\n            this.img.drawLine(x1, y1, x2, y2, color);\n        }\n\n        return endPos;\n    }\n\n    private parsePath(startPos: number): number {\n        // Find the end of the tag\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        if (endPos < 0) endPos = this.svgText.length;\n        let tag = this.svgText.substr(startPos, endPos);\n\n        // Get path data and stroke color\n        let d = this.getStringAttr(tag, \"d\");\n        let color = this.colorFromAttr(tag, \"stroke\");\n\n        // Tokenize: replace commas with spaces, then split on spaces\n        d = d.replace(\",\", \" \");\n        while (d.indexOf(\",\") >= 0) d = d.replace(\",\", \" \");\n        let rawTokens = d.trim().split(\" \");\n        let tokens: string[] = [];\n        for (let t of rawTokens) {\n            let tt = t.trim();\n            if (tt.length > 0) tokens.push(tt);\n        }\n\n        let prevX = 0;\n        let prevY = 0;\n        let startX = 0;\n        let startY = 0;\n        let i = 0;\n\n        while (i < tokens.length) {\n            let cmd = tokens[i++];\n            let isRelative = (cmd >= \"a\" && cmd <= \"z\");\n            cmd = cmd.toUpperCase();\n\n            if (cmd == \"M\" || cmd == \"L\") {\n                let x = parseFloat(tokens[i++]);\n                let y = parseFloat(tokens[i++]);\n                if (isRelative) { x += prevX; y += prevY; }\n                x = this.scaleX(x);\n                y = this.scaleY(y);\n                if (cmd == \"L\") {\n                    this.img.drawLine(prevX, prevY, x, y, color);\n                }\n                prevX = x;\n                prevY = y;\n                if (cmd == \"M\") { startX = x; startY = y; }\n            }\n            else if (cmd == \"H\") {\n                let x = parseFloat(tokens[i++]);\n                if (isRelative) x += prevX;\n                x = this.scaleX(x);\n                this.img.drawLine(prevX, prevY, x, prevY, color);\n                prevX = x;\n            }\n            else if (cmd == \"V\") {\n                let y = parseFloat(tokens[i++]);\n                if (isRelative) y += prevY;\n                y = this.scaleY(y);\n                this.img.drawLine(prevX, prevY, prevX, y, color);\n                prevY = y;\n            }\n            else if (cmd == \"Z\") {\n                // Close path\n                this.img.drawLine(prevX, prevY, startX, startY, color);\n                prevX = startX;\n                prevY = startY;\n            }\n            else if (cmd == \"C\") {\n                let x1 = this.scaleX(parseFloat(tokens[i++]));\n                let y1 = this.scaleY(parseFloat(tokens[i++]));\n                let x2 = this.scaleX(parseFloat(tokens[i++]));\n                let y2 = this.scaleY(parseFloat(tokens[i++]));\n                let x = this.scaleX(parseFloat(tokens[i++]));\n                let y = this.scaleY(parseFloat(tokens[i++]));\n\n                this.drawCubicBezier(prevX, prevY, x1, y1, x2, y2, x, y, color);\n                prevX = x;\n                prevY = y;\n            }\n            else if (cmd == \"Q\") {\n                let x1 = this.scaleX(parseFloat(tokens[i++]));\n                let y1 = this.scaleY(parseFloat(tokens[i++]));\n                let x = this.scaleX(parseFloat(tokens[i++]));\n                let y = this.scaleY(parseFloat(tokens[i++]));\n\n                this.drawQuadraticBezier(prevX, prevY, x1, y1, x, y, color);\n                prevX = x;\n                prevY = y;\n            }\n            else if (cmd == \"A\") {\n                let rx = parseFloat(tokens[i++]);\n                let ry = parseFloat(tokens[i++]);\n                let rotation = parseFloat(tokens[i++]); // ignored\n                let largeArc = parseInt(tokens[i++]);   // ignored\n                let sweep = parseInt(tokens[i++]);      // ignored\n                let x = this.scaleX(parseFloat(tokens[i++]));\n                let y = this.scaleY(parseFloat(tokens[i++]));\n\n                // Approximate arc as circular\n                let r = Math.min(rx, ry) * (160 / this.viewBoxW); // scale radius\n                this.drawArc(prevX, prevY, x, y, Math.round(r), color);\n                prevX = x;\n                prevY = y;\n            }\n            else {\n                // Unsupported command â€” skip numbers until next letter\n                while (i < tokens.length && !(tokens[i].length == 1 && tokens[i].toUpperCase() >= \"A\" && tokens[i].toUpperCase() <= \"Z\")) {\n                    i++;\n                }\n            }\n        }\n\n        return endPos;\n    }\n\n    \n\n    private drawQuadraticBezier(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, color: number) {\n        let steps = this.SmoothCurveAccuracy;\n        let prevX = x0;\n        let prevY = y0;\n        for (let t = 0; t <= steps; t++) {\n            let u = t / steps;\n            let x = (1 - u) * (1 - u) * x0 + 2 * (1 - u) * u * x1 + u * u * x2;\n            let y = (1 - u) * (1 - u) * y0 + 2 * (1 - u) * u * y1 + u * u * y2;\n            this.img.drawLine(prevX, prevY, Math.round(x), Math.round(y), color);\n            prevX = Math.round(x);\n            prevY = Math.round(y);\n        }\n    }\n\n    private drawArc(x0: number, y0: number, x1: number, y1: number, r: number, color: number) {\n        let steps = this.SmoothCurveAccuracy;\n        let cx = (x0 + x1) / 2;\n        let cy = (y0 + y1) / 2;\n        let angleStart = Math.atan2(y0 - cy, x0 - cx);\n        let angleEnd = Math.atan2(y1 - cy, x1 - cx);\n\n        // Ensure angleEnd > angleStart\n        if (angleEnd < angleStart) angleEnd += 2 * Math.PI;\n\n        let prevX = x0;\n        let prevY = y0;\n        for (let t = 1; t <= steps; t++) {\n            let angle = angleStart + (angleEnd - angleStart) * (t / steps);\n            let x = cx + r * Math.cos(angle);\n            let y = cy + r * Math.sin(angle);\n            this.img.drawLine(prevX, prevY, Math.round(x), Math.round(y), color);\n            prevX = Math.round(x);\n            prevY = Math.round(y);\n        }\n    }\n\n    private drawCubicBezier(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, color: number) {\n        let steps = this.SmoothCurveAccuracy;\n        let prevX = x0;\n        let prevY = y0;\n        for (let t = 0; t <= steps; t++) {\n            let u = t / steps;\n            let x = Math.pow(1 - u, 3) * x0 +\n                3 * Math.pow(1 - u, 2) * u * x1 +\n                3 * (1 - u) * u * u * x2 +\n                u * u * u * x3;\n            let y = Math.pow(1 - u, 3) * y0 +\n                3 * Math.pow(1 - u, 2) * u * y1 +\n                3 * (1 - u) * u * u * y2 +\n                u * u * u * y3;\n            this.img.drawLine(prevX, prevY, Math.round(x), Math.round(y), color);\n            prevX = Math.round(x);\n            prevY = Math.round(y);\n        }\n    }\n\n    private parseRect(startPos: number): number {\n        let endPos = this.svgText.indexOf(\",\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x = this.getAttr(tag, \"x\");\n        let y = this.getAttr(tag, \"y\");\n        let w = this.getAttr(tag, \"width\");\n        let h = this.getAttr(tag, \"height\");\n        let color = this.colorFromAttr(tag, \"fill\");\n\n        this.img.fillRect(this.scaleX(x), this.scaleY(y), this.scaleX(w), this.scaleY(h), color);\n        return endPos;\n    }\n\n    private parseCircle(startPos: number): number {\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let cx = this.getAttr(tag, \"cx\");\n        let cy = this.getAttr(tag, \"cy\");\n        let r = this.getAttr(tag, \"r\")\n        let color = this.colorFromAttr(tag, \"fill\");\n        this.img.fillCircle(this.scaleX(cx), this.scaleY(cy), Math.round(r * (160 / this.viewBoxW)), color);\n        return endPos;\n    }\n\n    private parseLine(startPos: number): number {\n        let endPos = this.svgText.indexOf(\">\", startPos);\n        let tag = this.svgText.substr(startPos, endPos);\n\n        let x1 = this.getAttr(tag, \"x1\");\n        let y1 = this.getAttr(tag, \"y1\");\n        let x2 = this.getAttr(tag, \"x2\");\n        let y2 = this.getAttr(tag, \"y2\");\n\n        let color = this.colorFromAttr(tag, \"stroke\");\n        this.img.drawLine(this.scaleX(x1), this.scaleY(y1), this.scaleX(x2), this.scaleY(y2), color);\n\n        return endPos;\n    }\n    // New: map an SVG hex color to your chosen palette\n    private colorFromAttr(tag: string, attrName: string): number {\n        let hex = this.getStringAttr(tag, attrName);\n        if (hex.length == 0) return 1; // default white if missing\n        if (hex.charAt(0) == '#') hex = hex.substr(1);\n\n        let r = parseInt(hex.substr(0, 2), 16);\n        let g = parseInt(hex.substr(2, 2), 16);\n        let b = parseInt(hex.substr(4, 2), 16);\n\n        // RGB values for closest-match calculation\n        const palette: number[][] = [\n            [255, 255, 255], // 1 white (#FFFFFF)\n            [255, 33, 33],   // 2 red (#FF2121)\n            [255, 147, 196], // 3 pink (#FF93C4)\n            [255, 129, 53],  // 4 orange (#FF8135)\n            [255, 246, 9],   // 5 yellow (#FFF609)\n            [36, 156, 170],  // 6 cyan-ish (#249CAA)\n            [120, 220, 82],  // 7 green (#78DC52)\n            [0, 63, 173],    // 8 dark blue (#003FAD)\n            [135, 242, 255], // 9 light blue (#87F2FF)\n            [142, 46, 196],  // 10 purple (#8E2EC4)\n            [164, 131, 159], // 11 mauve (#A4839F)\n            [92, 64, 156],   // 12 indigo (#5C409C)\n            [229, 205, 196], // 13 pale brown (#E5CDC4)\n            [145, 70, 61],   // 14 deep brown (#91463D)\n            [0, 0, 0]        // 15 black (#000000)\n        ];\n\n        // Matching palette indexes in MakeCode Arcade\n        const paletteIndex: number[] = [\n            1,  // white\n            2,  // red\n            3,  // pink\n            4,  // orange\n            5,  // yellow\n            6,  // cyan-ish\n            7,  // green\n            8,  // dark blue\n            9,  // light blue\n            10, // purple\n            11, // mauve\n            12, // indigo\n            13, // pale brown\n            14, // deep brown\n            15  // black\n        ];\n\n        let bestIndex = 1;\n        let bestDist = 999999;\n        for (let i = 0; i < palette.length; i++) {\n            let dr = palette[i][0] - r;\n            let dg = palette[i][1] - g;\n            let db = palette[i][2] - b;\n            let dist = dr * dr + dg * dg + db * db;\n            if (dist < bestDist) {\n                bestDist = dist;\n                bestIndex = paletteIndex[i];\n            }\n        }\n        return bestIndex;\n    }\n\n    // Slightly refactored getAttr to get numbers\n    private getAttr(tag: string, name: string): number {\n        let valStr = this.getStringAttr(tag, name);\n        if (valStr.length > 0) return parseFloat(valStr);\n        return 0;\n\n    }\n\n    // New: get string attribute (for colors)\n    private getStringAttr(tag: string, name: string): string {\n        let pos = tag.indexOf(name + \"=\");\n        if (pos >= 0) {\n            let quote1 = tag.indexOf('\"', pos);\n            let quote2 = tag.indexOf('\"', quote1 + 1);\n            return tag.substr(quote1 + 1, quote2).trim();\n        }\n        return \"\";\n    }\n\n}","pxt.json":"{\n    \"name\": \"SVG parser.\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"svgparse.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1756256206076}